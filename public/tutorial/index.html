<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
  <link rel="manifest" href="../site.webmanifest">
  <link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#00aba9">
  <meta name="theme-color" content="#ffffff">
  <title>Javascript Decorators</title>
  <link rel="stylesheet" href="../css/app.css">
  <script src="../js/codeflask.min.js"></script>
</head>
<body>
<div class="header">
  <h1>Javascript <a href="https://github.com/tc39/proposal-decorators"><em>Proposal</em></a>
    Decorators Tutorial</h1> | &nbsp;<a href="../">Playground</a> | &nbsp;<a href="../reference/">Quick Reference</a>
  <div class="version">version <span id="version"></span></div>
</div>
<a href="https://github.com/pabloalmunia/javacriptdecorators" class="github-corner"
   aria-label="View source on GitHub">
  <svg width="50" height="50" viewBox="0 0 250 250"
       style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"
       aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
    <path
        d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
        fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
    <path
        d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
        fill="currentColor" class="octo-body"></path>
  </svg>
</a>
<div class="content tutorial">
  <div class="section-left">
    <div class="subheader">
      <h2 class="selected">Tutorial</h2>
    </div>
    <div id="tutorial">
      <p class="header">
        <select id="navigator">
        </select>
        <span id="current"></span>/<span id="total"></span>
      </p>
      <div class="sections">
      <section id="introduction">
        <h2>Introduction</h2>
        <p>This tutorial describes step by step how to use and build the new Javascript decorators.
          The decorators provide a defined way to add features or metadata to class declarations and
          class members.</p>
        <p>Javascript decorators specification are in stage 2 of standardized process and is
          subject to change before incorporating it into the Javascript standard. You can also
          review the <a href="https://github.com/tc39/proposal-decorators">proposal
            documentation</a> for more information.</p>
        <p>This interactive tutorial will help you get started with Javascript decorators and see
          how easy it is to use and build these new elements. Each step of this tutorial introduces
          one or two decorator features.</p>
        <p>Use the interactive editor to add features to the initial code sample and see the result
          in the console. If you have problems with a step, click the "resolve" button to see the
          finished code, or click the "reset" button to return to the initial code.</p>
        <script type="origin">
// This area is for your exercise
console.log('this message is displayed on console window');
        </script>
        <script type="resolve">
// This area is for your exercise
console.log('this message is displayed on console window');
console.log('you have clicked on "resolve" button');
        </script>
      </section>
      <section id="use-decorator">
        <h2>Use a decorator</h2>
        <p>Let's discover how to use a decorator in your classes. Remember that decorators provide
          a way to add functionality to your classes and class members. We will use very simple
          decorators in this tutorial. Real-life decorators usually give much more value.</p>
        <p>Usually, the decorator is obtained with an import expression. Decorators are functions
          and can be imported without problems from modules. Of course, they can also be written
          the decorator and the class in the same script, especially while learning how they
          work.</p>
        <p>The first key point is that the decorator is applied with <code>@</code> before the
          decorator's name and writing this statement before the decorated element. The decorator
          can be written on the same line as the decorated element or on the lines before it.</p>
        <p> A decorator can be attached to a class or a class member (methods, getter/setter,
          fields, public, private, or static).</p>
        <h3>Exercise</h3>
        <p>The objective is to apply the decorator to the class and method:</p>
        <ul>
          <li>Write <code>@simpleDecorator</code> before the <code>class C</code>. A message should
            appear in the console window.
          </li>
          <li>Write <code>@simpleDecorator</code> before the <code>m()</code>. Two messages should
            appear in the console window, one for the method and one about decorating the class.
          </li>
        </ul>
        <script type="origin">
import simpleDecorator from './lib/simple-decorator.js';

class C {
  m() {
  }
}
        
        
        </script>
        <script type="resolve">
import simpleDecorator from './lib/simple-decorator.js';

@simpleDecorator
class C {
  @simpleDecorator
  m() {
  }
}
        
        
        </script>
      </section>
      <section id="use-decorator-with-parameters">
        <h2>Use a decorator with parameters</h2>
        <p>Some decorators need explicit configurations for their work. In these cases, the
          decorator is called as a function with parenthesis, and the parameters are included
          between them.</p>
        <p>You have to read the decorator's documentation to know the accepted and necessary
          parameters for each decorator.</p>
        <h3>Exercise</h3>
        <p>The objective is to run the <code>@log()</code> decorator with different
          options:</p>
        <ul>
          <li>Write <code>@log ('warn')</code> before the class method <code>sum()</code>. A
            warning is displayed in the console.
          </li>
          <li>Change the decorator parameter to <code>log</code> or <code>error</code>.</li>
        </ul>
        <script type="origin">
import log from './lib/simple-log.js';

class C {
  sum (a, b) {
    return a + b;
  }
}

const c = new C ();
c.sum (1, 2);
        
        
        </script>
        <script type="resolve">
import log from './lib/simple-log.js';

class C {
  @log ('warn')
  sum (a, b) {
    return a + b;
  }
}

const c = new C ();
c.sum (1, 2);
        
        
        </script>
      </section>
      <section id="use-decorator-init">
        <h2>Use decorator with @init</h2>
        <p>In some cases, the decorator requires to be invoked with <code>@init:</code>. This clause
          is necessary when the decorator needs to include an initializer function to rightly apply
          the decorator.</p>
        <p>You have to read the decorator's documentation to know what is the correct way to call
          it.</p>
        <h3>Exercise</h3>
        <p>The objective is to see the difference between <code>@init:log</code> and
          <code>@log</code>.</p>
        <ul>
          <li>Write <code>@init:log</code> before the class method <code>sum()</code>. See the
            console result.
          </li>
          <li>Remove <code>init:</code> and keep <code>@log</code> before the class method
            <code>sum()</code>. See the result and check the difference with the previous execution.
          </li>
        </ul>
        <script type="origin">
import log from './lib/simple-log-init.js';

class C {
  sum (a, b) {
    return a + b;
  }
}

const c = new C ();
c.sum (1, 2);
        
        
        
        </script>
        <script type="resolve">
import log from './lib/simple-log-init.js';

class C {
  @init:log
  sum (a, b) {
    return a + b;
  }
}

const c = new C ();
c.sum (1, 2);
        
        
        </script>
      </section>
      <section id="decorator-order">
        <h2>Decorator order</h2>
        <p>If a class or a class member has several decorators, these are called from left to
          right and from top to bottom.</p>
        <p>The member class decorators are called before the class decorators.</p>
        <p>The static member class decorators are called after the class decorators.</p>
        <h3>Exercise</h3>
        <p>The objective is to understand the decorator execution order.</p>
        <ul>
          <li>Include into the <code>@order( _ )</code> the applied position for each decorator,
            from 1 to 6.
          </li>
        </ul>
        <script type="origin">
import order from './lib/applied-order.js';

@order( )
class C {

  @order( )
  @order( )
  @order( )
  #p = 10;

  @order( )
  m() {}

  @order( )
  static M() {}
}
        
        
        
        </script>
        <script type="resolve">
import order from './lib/applied-order.js';

@order( 5 )
class C {

  @order( 1 )
  @order( 2 )
  @order( 3 )
  #p = 10;

  @order( 4 )
  m() {}

  @order( 6 )
  static M() {}
}
        
        
        </script>
      </section>
      <section id="build-simple-decorator">
        <h2>Build a simple decorator</h2>
        <p>Build your own decorator is very simple. A decorator is a function that receives two
          parameters, the first is the element decorated, and the second is an object with
          information and helpers (we will see this context object in the next steps in this
          tutorial).</p>
        <p>The return of our decorator can replace the element decorated. For example, if it
          returns a new function, this function replaces the method.</p>
        <h3>Exercise</h3>
        <p>The objective is to create a decorator <code>myDecorator</code> that
          writes in the console when a method is called.</p>
        <ul>
          <li>Create a function with <code>function myDecorator(method) {}</code>.</li>
          <li>This first function return a new function: <code>return function (...args) {}</code>.</li>
          <li>Inside the returned function write a <code>console.log('method called')</code>.</li>
          <li>Inside the returned function write a call to the original method:
            <code>return method.apply(this, args)</code>.</li>
          <li>Apply the decorator over the <code>sum()</code> method.</li>
        </ul>
        <script type="origin">
class C {
  sum(a, b) {
    return a + b;
  }
}

const c = new C();
c.sum(1,2);
        
        
        </script>
        <script type="resolve">
function myDecorator(method) {
  return function(...args) {
    console.log('method called');
    return method.apply(this, args);
  }
}

class C {
  @myDecorator
  sum(a, b) {
    return a + b;
  }
}

const c = new C();
c.sum(1,2);

        
        </script>
      </section>
      <section id="build-decorator-with-parameters">
        <h2>Build a decorator with parameters</h2>
        <p>If your decorator needs to receive configuration options, you must create a function that
          receives this information as parameters and returns the decorator function. You need two
          nested functions, the first function gets the configuration and the second function is
          the decorator.</p>
        <h3>Exercise</h3>
        <p>The objective is to create <code>myLog</code> decorator. This decorator
          receives a message and displays this in the console when the decorator is applied:</p>
        <ul>
          <li>Create a function with <code>function myLog(message) {}</code></li>
          <li>In this function return the decorator function: <code>return function () {}</code>.
          </li>
          <li>Inside the returned function write a <code>console.log(message)</code>.</li>
          <li>Add the decorator <code>@myLog('the method "sum()" is deprecated')</code> to the
            <code>sum()</code> method.
          </li>
        </ul>
        <script type="origin">
class C {
  sum(a, b) {
    return a + b;
  }
}
        </script>
        <script type="resolve">
function myLog(message) {
  return function() {
    console.log(message);
  }
}

class C {
  @myLog('the method "sum()" is deprecated')
  sum(a, b) {
    return a + b;
  }
}
        </script>
      </section>
      <section id="class-decorator">
        <h2>Class decorator</h2>
        <p>Decorators can be applied to the class and to the class members. We need a way to
          identify the type of element on which our decorator is applied. The decorator's second
          parameter is the solution. This <code>context</code> has a property <code>kind</code>
          that contains the kind of element our decorator is operating.</p>
        <p>A class decorator can check the correct element with
          <code>context.kind === 'class'</code> and cancel de execution if the type is other.
          Normally, decorators do not throw an error when applied to an element for which they are
          not prepared and ignore the case.</p>
        <p>The decorator receives the class and can check or modify the class content, such as
          adding a new method into the prototype or checking if a method is implemented.</p>
        <h3>Exercise</h3>
        <p>The objective is to add a new method into the class prototype:</p>
        <ul>
          <li>Copy the <code>sum</code> decorator and paste with the name <code>min</code>.</li>
          <li>Change <code>sum</code> with <code>min</code> in all locations and change
            the operator from <code>+</code> to <code>-</code>.
          </li>
          <li>Add <code>@min</code> to the class.</li>
          <li>Check the result with <code>console.log('c.min(1,2) =', c.min(1, 2))</code>.</li>
        </ul>
        <script type="origin">
function sum(element, context) {
  if (context.kind !== 'class') {
    return;
  }
  element.prototype.sum = function(a, b) {
    return a + b;
  }
}

@sum
class C {
}

const c = new C();
console.log('c.sum(1,2) =', c.sum(1, 2));
        
        
        </script>
        <script type="resolve">
function sum(element, context) {
  if (context.kind !== 'class') {
    return;
  }
  element.prototype.sum = function(a, b) {
    return a + b;
  }
}

function min(element, context) {
  if (context.kind !== 'class') {
    return;
  }
  element.prototype.min = function(a, b) {
    return a - b;
  }
}

@sum
@min
class C {
}

const c = new C();
console.log('c.sum(1,2) =', c.sum(1, 2));
console.log('c.min(1,2) =', c.min(1, 2));
        
        
        </script>
      </section>
      <section id="class-decorator-replace">
        <h2>A class decorator can replace the class</h2>
        <p>When the decorated element is a class, we can optionally return a new class and replace
          the original one. We must be careful replacing the class because we can break the code
          that uses the class that expects a specific behavior or signature. A possible solution is
          to create a new class that inherits from the original.</p>
        <h3>Exercise</h3>
        <p>The objective is to create a class decorator that adds two methods by
          inheriting from the original class:</p>
        <ul>
          <li>Create the decorator with <code>function operations(element, context)</code>.</li>
          <li>Cancel de execution if <code>context.kind</code> is different to <code>"class"</code>.
          </li>
          <li>Return a new class that inherits from the original class with
            <code>return class extends element {}</code>.
          </li>
          <li>Inside this inherited class add two methods: <code>mul(a,b) { return a * b }</code>
            and <code>div(a,b) { return a / b }</code>.
          </li>
          <li>Apply the decorator on the class with <code>@operations</code>.</li>
          <li>Check the result with two <code>console.log</code> at the end of the code.</li>
        </ul>
        <script type="origin">
class C {
  sum(a, b) {
    return a + b;
  }
  min(a, b) {
    return a - b;
  }
}

const c = new C();
console.log('c.sum(1,2) =', c.sum(1,2));
console.log('c.min(1,2) =', c.min(1,2));
        
        
        </script>
        <script type="resolve">
function operations(element, context) {
  if (context.kind !== 'class') {
    return;
  }
  return class extends element {
    mul(a,b) {
      return a * b;
    }
    div(a,b) {
      return a / b;
    }
  }
}

@operations
class C {
  sum(a, b) {
    return a + b;
  }
  min(a, b) {
    return a - b;
  }
}

const c = new C();
console.log('c.sum(1,2) =', c.sum(1,2));
console.log('c.min(1,2) =', c.min(1,2));
console.log('c.mul(1,2) =', c.mul(1,2));
console.log('c.div(1,2) =', c.div(1,2));
        
        
        </script>
      </section>
      <section id="method-decorator">
        <h2>Method decorator</h2>
        <p>These decorators receive the method, check its characteristics, and optionally return a
          new function to replacing the original method.</p>
        <p>The method decorators can check the kind element with
          <code>context.kind === 'method'</code>.</p>
        <h3>Exercise</h3>
        <p>The objective is to write a <code>@log</code> that wraps the original method and writes
          in the console the method's name (included in the <code>context.name</code>), the
          parameters, and the return value when the method is called:</p>
        <ul>
          <li>Create the decorator with <code>function log(method, context) {}</code>.</li>
          <li>Check if <code>context.kind</code> is equal to <code>"method"</code>.</li>
          <li>Return a new function with <code>return function(...args) {}</code>.</li>
          <li>In this function, call to the original method with <code>const result =
            method.apply(this, args)</code>.
          </li>
          <li>Use <code>console.log</code> to write the method name, the parameters and the result.
          </li>
          <li>Include in this function <code>return result</code>.</li>
          <li>Apply this decorator to the methods.</li>
        </ul>
        <script type="origin">
class C {
  value = 0;
  sum(n) {
    this.value = this.value + n;
    return this.value;
  }
  min(n) {
    this.value = this.value - n;
    return this.value;
  }
  mul(n) {
    this.value = this.value * n;
    return this.value;
  }
  div(n) {
    this.value = this.value / n;
    return this.value;
  }
}

const c = new C();
c.sum(10);
c.min(5);
c.mul(6);
c.div(2);
console.log(c.value);
        
        
        </script>
        <script type="resolve">
function log(method, context) {
  if (context.kind !== 'method') {
    return;
  }
  return function(...args) {
    const result = method.apply(this, args);
    console.log(
      'the method', '"' + context.name + '"',
      'is called with', args.join(', ') || 'undefined',
      'and return', result
    );
    return result;
  }
}

class C {
  value = 0;
  @log sum(n) {
    this.value = this.value + n;
    return this.value;
  }
  @log min(n) {
    this.value = this.value - n;
    return this.value;
  }
  @log mul(n) {
    this.value = this.value * n;
    return this.value;
  }
  @log div(n) {
    this.value = this.value / n;
    return this.value;
  }
}

const c = new C();
c.sum(10);
c.min(5);
c.mul(6);
c.div(2);
console.log(c.value);
        
        
        </script>
      </section>
      <section id="getter-setter-decorator">
        <h2>Getter/Setter decorator</h2>
        <p>A decorator applied to a getter or setter is very similar to a method decorator. You can
          identify this kind of decorator with the values <code>"getter"</code> and
          <code>"setter"</code> into <code>context.kind</code>.</p>
        <p>These decorators apply only for a getter or a setter. If you need to decorate both, you
          can put a decorator in each function, i.e., you must write a decorator for the getter
          <code>@log get value() {}</code>, and a decorator for the setter
          <code>@log set value(v) {}</code>.</p>
        <h3>Exercise</h3>
        <p>The objective is to adapt the previous exercise to getter/setter and apply it:</p>
        <ul>
          <li>Change the decorator for accept getter and setters.</li>
          <li>Apply <code>@log</code> to <code>get value()</code> and <code>set value(v)</code>.
          </li>
        </ul>
        <script type="origin">
function log(method, context) {
  if (context.kind !== 'method') {
    return;
  }
  return function(...args) {
    const result = method.apply(this, args);
    console.log(
      'the method', context.name,
      'is called with the parameters', args.join(', '),
      'and return', result
    );
    return result;
  }
}

class C {
  #value = 0;
  get value() {
    return this.#value;
  };
  set value(v) {
    this.#value = v;
  };
  sum(n) {
    this.value = this.value + n;
    return this.value;
  }
  min(n) {
    this.value = this.value - n;
    return this.value;
  }
  mul(n) {
    this.value = this.value * n;
    return this.value;
  }
  div(n) {
    this.value = this.value / n;
    return this.value;
  }
}

const c = new C();
c.sum(10);
c.min(5);
c.mul(6);
c.div(2);
console.log(c.value);
        
        
        </script>
        <script type="resolve">
function log(method, context) {
  if (context.kind !== 'method' && context.kind !== 'getter' && context.kind !== 'setter') {
    return;
  }
  return function(...args) {
    const result = method.apply(this, args);
    console.log(
      'the', context.kind, '"' + context.name + '"',
      'is called with', args.join(', ') || 'undefined',
      'and return', result
    );
    return result;
  }
}

class C {
  #value = 0;
  @log
  get value() {
    return this.#value;
  };
  @log
  set value(v) {
    this.#value = v;
  };
  sum(n) {
    this.value = this.value + n;
    return this.value;
  }
  min(n) {
    this.value = this.value - n;
    return this.value;
  }
  mul(n) {
    this.value = this.value * n;
    return this.value;
  }
  div(n) {
    this.value = this.value / n;
    return this.value;
  }
}

const c = new C();
c.sum(10);
c.min(5);
c.mul(6);
c.div(2);
console.log(c.value);
        
        
        </script>
      </section>
      <section id="field-decorator">
        <h2>Field decorator</h2>
        <p>The field decorator is a little different because the first parameter received by the
          decorator function is always <code>undefined</code>. As a result, we cannot operate
          directly on the field. To get the initial value and optionally change it, we must return
          a function that receives the initial value and can return the new initial value for the
          field.</p>
        <p>We can identify the field decorator with <code>context.kind</code> with the value
          <code>"field"</code>.</p>
        <h3>Exercise</h3>
        <p>The objective is to create a decorator than put a random value into a field:</p>
        <ul>
          <li>Create the decorator <code>function random(value, context) {}</code>.</li>
          <li>Check if the decorated element is or not a field.</li>
          <li>Return a function than return a random value
            <code>return function(value) { return Math.random(); }</code>.
          </li>
          <li>Apply the decorator <code>@random</code> to the field <code>num</code>.</li>
        </ul>
        <script type="origin">
class C {
  num = 0;
}

const c = new C();
console.log(c.num);
        
        
        </script>
        <script type="resolve">
function random(value, context) {
  if (context.kind !== 'field') {
    return;
  }
  return function(value) {
    return Math.random();
  }
}

class C {
  @random
  num = 0;
}

const c = new C();
console.log(c.num);
        
        
        </script>
      </section>
      <section id="auto-accessor">
        <h2>Auto accessor</h2>
        <p>The new <code>accessor</code> keyword before a class field defines internally a getter
          and setter for this field and storage the value into a private slot. This kind of element
          can be decorated, and the decorator receives as value an object with the getter and setter
          (<code>{get, set}</code>) and the <code>context.kind</code> is
          <code>"auto-accessor"</code>.</p>
        <p>Optionally the auto-accessor decorator can return an object with a new getter and/or a
          new setter (<code>{get, set}</code>) that replace the originals. In addition,
          auto-accessors decorators can add an <code>initialize</code> method used to
          change the initial value.</p>
        <h3>Exercise</h3>
        <p>The objective is to convert to number any value assigned to the <code>.num</code>
          property:</p>
        <ul>
          <li>Create the decorator <code>function number(value, context) {}</code>.</li>
          <li>Check if <code>context.kind</code> is <code>"auto-accessor</code>.</li>
          <li>Return a new object with a <code>{ set(v) {}}</code>.</li>
          <li>In the <code>set</code> method convert the parameter to number and call to the
            original <code>value.set.call(this, Number(v))</code>.
          </li>
          <li>Apply <code>@number accessor</code> to the <code>num</code> property.</li>
        </ul>
        <script type="origin">
class C {
  num = 0;
}

const c = new C();
c.num = '10';
console.log(typeof c.num);
        
        
        </script>
        <script type="resolve">
function number(value, context) {
  if (context.kind !== 'auto-accessor') {
    return;
  }
  return {
    set(v) {
      value.set.call(this, Number(v));
    }
  }
}

class C {
  @number
  accessor num = 0;
}

const c = new C();
c.num = '10';
console.log(typeof c.num);
        
        
        </script>
      </section>
      <section id="static-decorator">
        <h2>Static member decorator</h2>
        <p>The static class members (methods, fields, getter, setter, and auto accessors) can be
          decorated without problems and work in the same form as instance members. If you need
          to identify a static element, you can check if is <code>true</code> the property
          <code>context.isStatic</code>.</p>
        <h3>Exercise</h3>
        <p>The objective is to create a <code>log</code> decorator that displays a message when a
          static method, getter, or setter is called.</p>
        <ul>
          <li>Create the decorator <code>function log(value, context) {}</code></li>
          <li>Check if the decorated element kind is <code>'method'</code>, <code>'getter'</code>
            or <code>'setter'</code>.
          </li>
          <li>Return a wrapped function for the original element.</li>
          <li>In this wrapped function, call to the original element.</li>
          <li>Write in the console a message with information about the method, includes if it is
            static.
          </li>
        </ul>
        <script type="origin">
class C {
  static sqr(v) {
    return v * v;
  }
}

console.log(C.sqr(12));
        
        
        </script>
        <script type="resolve">
function log (value, context) {
  if (!['method', 'getter', 'setter'].includes(context.kind)) {
    return;
  }
  return function(...args) {
    const result = value.apply(this, args);
    console.log(
      context.isStatic ? 'static' : '',
      context.kind + ' ' + context.name,
      'is called with (' + args.join(', ') + ')',
      'and return the value ' + result);
    return result;
  }
}
class C {
  @log
  static sqr(v) {
    return v * v;
  }
}

console.log(C.sqr(12));
        
        
        </script>
      </section>
      <section id="private-decorator">
        <h2>Private member decorator</h2>
        <p>It's straightforward to identify a private member decorator: the property
          <code>context.isPrivate</code> is <code>true</code>. When a decorator is applied to a
          private member, the decorator has some limitations because it cannot use
          <code>context.name</code> to access the member. The name included in this property is
          only for informational proposal. For access to the private member, we must use
          <code>context.access</code> and its methods <code>get()</code> and <code>set(v)</code>.
        </p>
        <p>The rest of the functionalities are precisely the same for each type of decorator, and
          we can use everything we have learned so far in this tutorial.</p>
        <h3>Exercise</h3>
        <p>The objective is to complete the log decorator with a message, including if the member
          is private.</p>
        <ul>
          <li>Update the <code>get()</code> and
            <cod>set()</cod>
            methods for writing a message when
            the decorator is applied to a private member.
          </li>
          <li>Apply <code>@log</code> to <code>#value</code> private auto accessor field.</li>
        </ul>
        <script type="origin">
function log(value, context) {
  if (context.kind !== 'auto-accessor') {
    return;
  }
  return {
    get() {
      const result = value.get.call(this);
      console.log( 'get', '"' + context.name + '"', '=', result );
      return result;
    },
    set(v) {
      value.set.call(this, v);
      console.log( 'set', '"' + context.name + '"', '=', v );
    }
  };
}

class C {
  accessor #value = 0;
  sum(n) {
    return this.#value = this.#value + n;
  }
  min(n) {
    return this.#value = this.#value - n;
  }
  mul(n) {
    return this.#value = this.#value * n;
  }
  div(n) {
    return this.#value = this.#value / n;
  }
  result() {
    return this.#value;
  }
}

const c = new C();
c.sum(10);
c.min(5);
c.mul(6);
c.div(2);
console.log(c.result());
        
        
        </script>
        <script type="resolve">
function log(value, context) {
  if (context.kind !== 'auto-accessor') {
    return;
  }
  return {
    get() {
      const result = value.get.call(this);
      console.log(
        context.isPrivate ? 'private' : '',
        'get', '"' + context.name + '"',
        '=', result
      );
      return result;
    },
    set(v) {
      value.set.call(this, v);
      console.log(
        context.isPrivate ? 'private' : '',
        'set', '"' + context.name + '"',
        '=', v
      );
    }
  };
}

class C {
  @log
  accessor #value = 0;
  sum(n) {
    return this.#value = this.#value + n;
  }
  min(n) {
    return this.#value = this.#value - n;
  }
  mul(n) {
    return this.#value = this.#value * n;
  }
  div(n) {
    return this.#value = this.#value / n;
  }
  result() {
    return this.#value;
  }
}

const c = new C();
c.sum(10);
c.min(5);
c.mul(6);
c.div(2);
console.log(c.result());
        
        
        </script>
      </section>
      <section id="init-member-decorator">
        <h2>@init: member decorator</h2>
        <p>Some decorators need to be called with<code>@init:</code>. This form allows the decorator
          to add an initializer function. This initializer is executed:
        </p>
        <ul>
          <li>for member decorator, after the constructor (for each object)</li>
          <li>for static member decorators, after the class is defined</li>
          <li>for the class decorator, after the static member are defined.</li>
        </ul>
        <p>The decorator can check if it is called or not with <code>#init:</code> checked the
          function <code>context.addInitializer</code>. If exist it, the decorator is called with
          <code>@init:</code>. This function <code>context.addInitializer</code> is the form to
          add new initializer functions.</p>
        <h3>Exercise</h3>
        <p>The objective is to create a decorator with <code>@init:</code> that defines a
          field as read-only. It's essential to understand that the member initializer runs after
          the constructor.</p>
        <ul>
          <li>Create a decorator <code>function readonly(value, context) {}</code>.</li>
          <li>Check if the <code>context.addInitializer</code> exist and throw an error if not.
          </li>
          <li>Call to <code>context.addInitializer()</code> and pass as parameter a function that
            define the property as readonly with
            <code>Object.defineProperty(this, context.name, { get() { return value; }, set(v)
              {}});</code></li>
          <li>Apply the decorator to <code>n</code> field.</li>
        </ul>
        <script type="origin">
class C {
  n = 0;

  constructor(value) {
    this.n = value;
  }
}
const c = new C(30);
c.n = 20;
console.log(c.n);
        
        
        </script>
        <script type="resolve">
function readonly(value, context) {
  if (!context.addInitializer) {
    throw 'the readonly decorator must be applied with @init:';
  }
  context.addInitializer(function () {
    const value = this[context.name];
    Object.defineProperty(this, context.name, {
      get() {
        return value;
      },
      set(v) {}
    });
  });
}

class C {
  @init:readonly
  n = 0;

  constructor(value) {
    this.n = value;
  }
}
const c = new C(30);
c.n = 20;
console.log(c.n);
        
        
        </script>
      </section>
      <section id="metadata">
        <h2>Metadata</h2>
        <p>Decorators provide a simple way to add metadata to classes and their members. Some people
          use "annotation" as a synonym of "decorator" because one of their features is to annotate
          classes and class members with metadata.</p>
        <p>Metadata can be used by other decorators in a collaborative environment, can be used by
          other programs to recognize some features, can be used for debugging purposes, etc.</p>
        <p>We need a Symbol key for write metadata. This is the key to avoiding name collisions
          between different metadata sources. With this Symbol is used when we call to
          <code>context.setMetadata(key, value)</code> to add metadata and
          <code>context.getMetadata(key)</code> to get metadata of current decorated element.</p>
        <h3>Exercise</h3>
        <p>The objective is to create the <code>close</code> decorator that adds metadata, and the
          <code>log</code> decorator reads the metadata and avoids logging if the previous metadata
          is defined.</p>
        <ul>
          <li>Define a new Symbol with <code>const IS_HIDDEN = Symbol()</code>.</li>
          <li>Create the <code>hide</code> decorator that writes metadata with this Symbol:
            <code>context.setMetadata(IS_HIDDEN, true)</code>.
          </li>
          <li>Check the metadata with <code>context.getMetadata(IS_HIDDEN)</code> into
            <code>log</code> decorator and cancel the execution if the metadata is
            <code>true</code>.
          </li>
          <li>Add <code>@hide</code> before than <code>@log</code> (remember the decorator
            order: from top to bottom and left to right).
          </li>
        </ul>
        <script type="origin">
function log (value, context) {
  if (!['method', 'getter', 'setter'].includes(context.kind)) {
    return;
  }
  return function(...args) {
    const result = value.apply(this, args);
    console.log(
      context.isStatic ? 'static' : '',
      context.isPrivate ? 'private' : '',
      context.kind + ' ' + context.name,
      'is called with (' + args.join(', ') + ')',
      'and return the value ' + result);
    return result;
  }
}
class C {
  @log
  sum(a, b) {
    return a + b;
  }
}
const c = new C();
c.sum(1,2);
        </script>
        <script type="resolve">
const IS_HIDDEN = Symbol();

function hide(value, context) {
  context.setMetadata(IS_HIDDEN, true)
}

function log (value, context) {
  if (!['method', 'getter', 'setter'].includes(context.kind)) {
    return;
  }
  if (context.getMetadata(IS_HIDDEN)) {
     return console.log('the log is not added');
  }
  return function(...args) {
    const result = value.apply(this, args);
    console.log(
      context.isStatic ? 'static' : '',
      context.isPrivate ? 'private' : '',
      context.kind + ' ' + context.name,
      'is called with (' + args.join(', ') + ')',
      'and return the value ' + result);
    return result;
  }
}

class C {
  @hide
  @log
  sum(a, b) {
    return a + b;
  }
}
const c = new C();
c.sum(1,2);
        </script>
      </section>
      <section id="collaboration">
        <h2>Getting metadata</h2>
        <p>If you need to read the metadata outside the decorators of the same element, we need to
          find this metadata. The metadata is stored in the class with a particular structure, and
          we can access it if we have the original Symbol (<code>KEY</code>).</p>
        <p><code>Symbol.metadata</code> is a well know Symbol used for storing the metadata.
          Depending on whether the metadata has been defined, the class or the class element,
          public, private or static, the metadata is stored in different places.</p>
        <ul>
          <li>The class metadata is located in<br/><code>Class[Symbol.metadata][<i>KEY</i>].constructor</code>
          </li>
          <li>The public member metadata is located
            in<br/><code>Class.prototype[Symbol.metadata][<i>KEY</i>].public[<i>member_name</i>]</code>
          </li>
          <li>The private member metadata is located
            in<br/><code>Class.prototype[Symbol.metadata][<i>KEY</i>].private</code></li>
          <li>The static member metadata is located in<br/><code>Class[Symbol.metadata][<i>KEY</i>].public[<i>member_name</i>]</code>
          </li>
          <li>The static and private member metadata is located in<br/><code>Class[Symbol.metadata][<i>KEY</i>].private</code>
          </li>
        </ul>
        <p><i>Notice</i>: The private metadata doesn't have the member's private name and is an
          array with all private metadata.</p>
        <h3>Exercise</h3>
        <p>The objective is to check the metadata storage for each kind of element.</p>
        <ul>
          <li>Define a Symbol: <code>const MY_META = Symbol()</code></li>
          <li>Create a new decorator <code>meta</code> that receive a message and write the message
            as metadata.
          </li>
          <li>Add the <code>@meta()</code> decorator for each element with a descriptive
            parameter.
          </li>
          <li>Get all metadata with <code>console.log(C[Symbol.metadata][MY_META])</code> and
            <code>console.log(C.prototype[Symbol.metadata][MY_META])</code>.
          </li>
        </ul>
        <script type="origin">
class C {
  n = 0;
  m() {}
  #p = 1;

  static N = 0;
  static M() {}
  static #P = 1;
}
        </script>
        <script type="resolve">
const MY_META = Symbol();

function meta(message) {
  return function (value, context) {
    context.setMetadata(MY_META, message);
  }
}

@meta('class metadata')
class C {
  @meta ('field metadata')
  n = 0;
  @meta ('method metadata')
  m() {}
  @meta ('private field metadata')
  #p = 1;

  @meta ('static field metadata')
  static N = 0;
  @meta ('static method metadata')
  static M() {}
  @meta ('static and private field metadata')
  static #P = 1;
}

console.log('C[Symbol.metadata][MY_META]', C[Symbol.metadata][MY_META]);
console.log('C.prototype[Symbol.metadata][MY_META]', C.prototype[Symbol.metadata][MY_META]);
        </script>
      </section>
      <section id="final-exercise">
        <h2>Final exercise</h2>
        <p>This complete exercise has the objective of creating a set of decorators to obtain the
          object's state, create a history, and add an <code>undo()</code> method to restore
          previous states.</p>
        <p>In this case, we have to follow several steps::</p>
        <ul>
          <li>Create a Symbol as the key for our metadata:
            <pre>const HISTORY = Symbol()</pre>
          </li>
          <li>Create a WeakMap for storage the status for each object:
            <pre>const data    = new WeakMap();</pre>
          </li>
          <li>Create a <code>@mutation</code> decorator to set the methods that change the status:
            <pre>context.setMetadata (HISTORY, 'change');</pre>
          </li>
          <li>Create a <code>@state accessor</code> decorator to set the private field that
            stores the current status and put the access object into the metadata with
            <pre>context.setMetadata (HISTORY, context.access)</pre>
          </li>
          <li>Create an <code>@history</code> decorator with these features:
            <ul>
              <li>Get the access object saved into the metadata:<br/>
                <pre>const access = value.prototype[ Symbol.metadata ][ HISTORY ].private[0];</pre>
              </li>
              <li>Add the <code>history()</code> method to the prototype:
                <pre>
value.prototype.history = function () {
  if (!data.has(this)) {
    data.set(this, [])
  }
  return data.get(this)
};</pre>
              </li>
              <li>Add the <code>undo()</code> method to the prototype:
                <pre>
value.prototype.undo = function () {
  if (this.history().length) {
    access.set.call(this, this.history().pop () );
  }
};</pre>
              </li>
              <li>Wrap all methods annotated as a mutation with a new function that stores the
                previous state:
                <pre>
Object.keys (value.prototype[ Symbol.metadata ][ HISTORY ].public).forEach (method => {
  const fn = value.prototype[ method ];
  value.prototype[ method ] = function (...args) {
    this.history().push (access.get.call(this));
    return fn.apply (this, args);
  };
});</pre>
              </li>
            </ul>
          </li>
          <li>Apply the decorators:
            <ul>
              <li><code>@state</code> to <code>#value = 0</code>.</li>
              <li><code>@mutation</code> to <code>add()</code>, <code>sub()</code>,
                <code>mul()</code>, and <code>div()</code>.
              </li>
              <li><code>@history</code> to <code>class Calc</code></li>
            </ul>
          </li>
          <li>Now, you can call <code>calc.undo()</code> to restore the previous status.</li>
        </ul>
        
        <script type="origin">
class Calc {
  
  #value = 0;
  
  add (n) {
    return this.#value = this.#value + n;
  }
  sub (n) {
    return this.#value = this.#value - n;
  }
  mul (n) {
    return this.#value = this.#value * n;
  }
  div (n) {
    return this.#value = this.#value / n;
  }
  result () {
    return this.#value;
  }
}

const calc = new Calc ();
calc.add (10);
calc.add (20);
calc.add (30);
calc.add (40);
calc.mul (10);
calc.sub (1)
console.log (calc.result ()); // 999
        </script>
        <script type="resolve">
const HISTORY = Symbol ();
const data    = new WeakMap();

function mutation(value, context) {
  context.setMetadata (HISTORY, 'change');
}

function state (value, context) {
  context.setMetadata (HISTORY, context.access);
}

function history (value, context) {

  const access = value.prototype[ Symbol.metadata ][ HISTORY ].private[0];
  
  value.prototype.history = function () {
    if (!data.has(this)) {
      data.set(this, [])
    }
    return data.get(this)
  };
  
  value.prototype.undo = function () {
    if (this.history().length) {
      access.set.call(this, this.history().pop () );
    }
  };
  
  Object.keys (value.prototype[ Symbol.metadata ][ HISTORY ].public).forEach (method => {
    const fn = value.prototype[ method ];
    value.prototype[ method ] = function (...args) {
      this.history().push (access.get.call(this));
      return fn.apply (this, args);
    };
  });

}


@history
class Calc {
  
  @state accessor
  #value = 0;
  
  @mutation
  add (n) {
    return this.#value = this.#value + n;
  }
  
  @mutation
  sub (n) {
    return this.#value = this.#value - n;
  }
  
  @mutation
  mul (n) {
    return this.#value = this.#value * n;
  }
  
  @mutation
  div (n) {
    return this.#value = this.#value / n;
  }
  
  result () {
    return this.#value;
  }
}

const calc = new Calc ();
calc.add (10);
calc.add (20);
calc.add (30);
calc.add (40);
calc.mul (10);
calc.sub (1)
console.log (calc.result ()); // 999
calc.undo();
console.log (calc.result ()); // 1000
calc.undo();
console.log (calc.result ()); // 100
        </script>
      </section>
      <div id="resolve" class="button primary" title="revolve the exercise">resolve</div>
      <div id="reset" class="button secondary" title="reset the exercise">reset</div>
      </div>
      <div class="navigation">
        <div class="prev-parent"><span class="prev"><span class="arrow">&#8678;</span></span></div>
        <div class="next-parent"><span class="next"><strong>Next:</strong> <span
            id="next"></span> <span class="arrow">&#8680;</span></span></div>
      </div>
    </div>
  </div>
  <div class="resizer-ew">:<br/>:<br/>:</div>
  <div class="section-right">
    <div class="subheader">
      <h2>Source code</h2>
      <span id="message"></span>
    </div>
    <div id="code"></div>
    <div class="resizer-ns">....</div>
    <div class="subfooter">
      <h2>Console output</h2>
    </div>
    <div id="console"></div>
  </div>
</div>
<script src="../js/app.js"></script>
<script src="../js/tutorial.js"></script>
<script src="../js/resizer.js"></script>
</body>
</html>
